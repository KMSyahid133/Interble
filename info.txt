Intorduction:
    This is a esolang that doesn't work with lines, but with order code. 
    
    Example:

1   |   0000:x61; [This wirtes out 'a' and the order code is 1]
2   |   
3   |
4   |   0000:x62 [This writes out 'b' and the order code is 2]
5   |   0003:#1 [This has the order code of 3, this jump to order code 1, thus making a loop]
6   |
7   |
8   |
9   |
10  |   

Syntax:

Comments:
    To use comments, wrap the text around square brackets
    Example:
        [This is a command and will be ignored by the interpreter]

Code:
    The code syntax is simple, 4 character of hex followed by a colon,specifier and then value
    Command:SpecifierValue;
    Specifier:
        '&': value is a variable address
        'x': is a char value
        '#': is a number value
        'h': is a hexadecimal value
    Example:
        


Commands:
    0000: print                     args: any
        write the arg out to the output

    0001: input                     args: &
        get user input and store it at &arg
    0002: load                      args: & 
        change the pointer to &arg
    0003: save                      args: any 
        override the current loaded variable to arg
    0004: jump                      args: #
        change the current code index to #arg
    0005: increment                 args: &
        increment the &arg number by 1
    0006: decrement                 args: &
        decrement the &arg number by 1

    Comparison operator
        override the current laoded variable with the boolean result
        loadedVariable <op> arg

    0007: equality                  args: #    (==)     
        loadedVariable == arg

    0008: not equal                 args: #    (!= or ~=)
        loadedVariable != arg

    0009: more than                 args: #     (>)    
        loadedVariable > arg

    000A: less than                 args: #     (<)
        loadedVariable < arg

    000B: less than or equal        args: #     (<=)
        loadedVariable <= arg

    000C: more than or equal        args: #     (>=)
        loadedVariable >= arg


    000D: wait                      args: #
        wait # seconds

    000E: if statement              args: #
        if the current loaded variable is true, then it will continue, else it will go to order code #


    Arithmetic operations
        override the current loaded variable with the arithmetic result
        loadedVariable <op> arg

    000F: Addtion                   args: # | & | h
        loadedVariable + arg

    0010: Subtraction               args: # | & | h
        loadedVariable - arg

    0011: Multiplication            args: # | & | h
        loadedVariable * arg

    0012: Division                  args: # | & | h
        loadedVariable / arg

    0013: Modulo                    args: # | & | h
        loadedVariable % arg

    0014: Exponent                  args: # | & | h
        loadedVariable ^ arg


        